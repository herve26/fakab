// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgres"
  url      = env("DATABASE_URL")
}

model user {
  id       String  @id @default(cuid())
  email    String  @unique
  username String  @unique
  name     String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  image       user_image?
  password    password?
  notes       note[]
  roles       role[]
  sessions    session[]
  connections connection[]
}

model note {
  id      String @id @default(cuid())
  title   String
  content String

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  owner   user   @relation(fields: [ownerid], references: [id], onDelete: Cascade, onUpdate: Cascade)
  ownerid String

  images note_image[]

  // non-unique foreign key
  @@index([ownerid])
  // This helps our order by in the user search a LOT
  @@index([ownerid, updated_at])
}

model note_image {
  id          String  @id @default(cuid())
  alt_text     String?
  content_type String
  blob        Bytes

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  note   note   @relation(fields: [noteid], references: [id], onDelete: Cascade, onUpdate: Cascade)
  noteid String

  // non-unique foreign key
  @@index([noteid])
}

model user_image {
  id          String  @id @default(cuid())
  alt_text     String?
  content_type String
  blob        Bytes

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user   user   @relation(fields: [userid], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userid String @unique
}

model password {
  hash String

  user   user   @relation(fields: [userid], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userid String @unique
}

model session {
  id             String   @id @default(cuid())
  expiration_date DateTime

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user   user   @relation(fields: [userid], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userid String

  // non-unique foreign key
  @@index([userid])
}

model permission {
  id          String @id @default(cuid())
  action      String // e.g. create, read, update, delete
  entity      String // e.g. note, user, etc.
  access      String // e.g. own or any
  description String @default("")

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  roles role[]

  @@unique([action, entity, access])
}

model role {
  id          String @id @default(cuid())
  name        String @unique
  description String @default("")

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  users       user[]
  permissions permission[]
}

model verification {
  id        String   @id @default(cuid())
  created_at DateTime @default(now())

  /// The type of verification, e.g. "email" or "phone"
  type String

  /// The thing we're trying to verify, e.g. a user's email or phone number
  target String

  /// The secret key used to generate the otp
  secret String

  /// The algorithm used to generate the otp
  algorithm String

  /// The number of digits in the otp
  digits Int

  /// The number of seconds the otp is valid for
  period Int

  /// The valid characters for the otp
  charset String

  /// When it's safe to delete this verification
  expires_at DateTime?

  @@unique([target, type])
}

model connection {
  id           String @id @default(cuid())
  provider_name String
  providerid   String

  created_at DateTime @default(now())
  updated_at DateTime @updatedAt

  user   user   @relation(fields: [userid], references: [id], onDelete: Cascade, onUpdate: Cascade)
  userid String

  @@unique([provider_name, providerid])
}

model customer_connection {
  id String @id @default(cuid())
  
  so String @unique
  customer_details String
  customer_contact String
  customer_address String
  area String
  geo_localization String
  connection_type String
  has_mdu Boolean @default(false)
  assignement_date DateTime @default(now())
  completion_date DateTime?

  team team? @relation(fields: [teamid], references: [id])
  teamid Int?

  materials material_used[]

  documents document_resource[]
}

model material_used {
  customer customer_connection @relation(fields: [customerid], references: [id])
  customerid String

  material material @relation(fields: [materialid], references: [materialid])
  materialid Int

  quantity Int
  @@id([customerid, materialid])
}

model employee {
  employeeid Int @id @default(autoincrement())
  first_name String
  last_name String
  email String @unique
  start_date DateTime
  end_date DateTime?
  
  inchargeof team? @relation("inChargeRef", fields: [inchargeofid], references: [id])
  inchargeofid Int? @unique

  team team? @relation("teamRef", fields: [teamid], references: [id])
  teamid Int?
}

model team {
  id      Int      @id @default(autoincrement())
  name    String

  incharge employee? @relation("inChargeRef")

  members employee[] @relation("teamRef")

  connections customer_connection[]

  team_materials team_material[]
}

model team_material {
  team team @relation(fields: [teamid], references: [id])
  teamid Int

  material material @relation(fields: [materialid], references: [materialid])
  materialid Int

  quantity Int
  
  @@id([teamid, materialid])
}

model material {
  materialid Int @id @default(autoincrement())
  material_name String @unique
  material_code String @unique
  material_desc String?

  material_unit material_unit @relation(fields: [material_unit_code], references: [unit_code], onDelete: Cascade)
  material_unit_code String

  orderDetail order_detail[]

  teamMaterial team_material[]

  customerMaterial material_used[]
}

model material_unit {
  unit_code String @id
  unit_name String

  material material[]
}

enum order_status {
  PENDING
  FULFILLED
  CANCELLED
}
  
model order {
  orderid Int @id @default(autoincrement())
  order_date DateTime
  status order_status @default(PENDING)

  details order_detail[]

  supplier supplier? @relation(fields: [supplierid], references: [supplierid])
  supplierid Int?

}

model order_detail {
  order_detailid Int @id @default(autoincrement())
  order_quantity Int
  received_date DateTime?

  order order @relation(fields: [orderid], references: [orderid])
  orderid Int

  material material @relation(fields: [materialid], references: [materialid])
  materialid Int

  unit_price Decimal?
}

enum supplier_type {
  MERCHANT
  REFILL
}

model supplier {
  supplierid Int @id @default(autoincrement())
  supplier_name String
  contact_person String?
  phonenumber String?
  email String?
  address String?

  supplier_type supplier_type @default(MERCHANT) // Changed to String

  orders order[]
}

model document_template {
  documentid          Int       @id @default(autoincrement())
  document_name        String @unique
  document_desc String?
  document_code  String @unique
  document_type        String?   // Optional type for categorizing templates

  created_at   DateTime  @default(now())
  updated_at   DateTime  @updatedAt

  template_resource document_resource?
}

model document_resource {
  id          Int       @id @default(autoincrement())
  name        String
  content_type String?
  size        Int?
  tag         String?
  // Use a String to accommodate various file paths and storage options
  url         String?
  path        String
  created_at   DateTime  @default(now())
  updated_at   DateTime  @updatedAt
  
  customer    customer_connection? @relation(fields: [customerid], references: [id])
  customerid  String?

  documentTemplate document_template? @relation(fields: [document_templateid], references: [documentid])
  document_templateid Int? @unique
}
